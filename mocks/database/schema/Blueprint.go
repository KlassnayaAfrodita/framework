// Code generated by mockery. DO NOT EDIT.

package schema

import (
	orm "github.com/goravel/framework/contracts/database/orm"
	schema "github.com/goravel/framework/contracts/database/schema"
	mock "github.com/stretchr/testify/mock"
)

// Blueprint is an autogenerated mock type for the Blueprint type
type Blueprint struct {
	mock.Mock
}

type Blueprint_Expecter struct {
	mock *mock.Mock
}

func (_m *Blueprint) EXPECT() *Blueprint_Expecter {
	return &Blueprint_Expecter{mock: &_m.Mock}
}

// BigIncrements provides a mock function with given fields: column
func (_m *Blueprint) BigIncrements(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for BigIncrements")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_BigIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BigIncrements'
type Blueprint_BigIncrements_Call struct {
	*mock.Call
}

// BigIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) BigIncrements(column interface{}) *Blueprint_BigIncrements_Call {
	return &Blueprint_BigIncrements_Call{Call: _e.mock.On("BigIncrements", column)}
}

func (_c *Blueprint_BigIncrements_Call) Run(run func(column string)) *Blueprint_BigIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_BigIncrements_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_BigIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_BigIncrements_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_BigIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// BigInteger provides a mock function with given fields: column, config
func (_m *Blueprint) BigInteger(column string, config ...schema.IntegerConfig) schema.ColumnDefinition {
	_va := make([]interface{}, len(config))
	for _i := range config {
		_va[_i] = config[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BigInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...schema.IntegerConfig) schema.ColumnDefinition); ok {
		r0 = rf(column, config...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_BigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BigInteger'
type Blueprint_BigInteger_Call struct {
	*mock.Call
}

// BigInteger is a helper method to define mock.On call
//   - column string
//   - config ...schema.IntegerConfig
func (_e *Blueprint_Expecter) BigInteger(column interface{}, config ...interface{}) *Blueprint_BigInteger_Call {
	return &Blueprint_BigInteger_Call{Call: _e.mock.On("BigInteger",
		append([]interface{}{column}, config...)...)}
}

func (_c *Blueprint_BigInteger_Call) Run(run func(column string, config ...schema.IntegerConfig)) *Blueprint_BigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]schema.IntegerConfig, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(schema.IntegerConfig)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_BigInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_BigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_BigInteger_Call) RunAndReturn(run func(string, ...schema.IntegerConfig) schema.ColumnDefinition) *Blueprint_BigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// Binary provides a mock function with given fields: column
func (_m *Blueprint) Binary(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Binary")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Binary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Binary'
type Blueprint_Binary_Call struct {
	*mock.Call
}

// Binary is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Binary(column interface{}) *Blueprint_Binary_Call {
	return &Blueprint_Binary_Call{Call: _e.mock.On("Binary", column)}
}

func (_c *Blueprint_Binary_Call) Run(run func(column string)) *Blueprint_Binary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Binary_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Binary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Binary_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Binary_Call {
	_c.Call.Return(run)
	return _c
}

// Boolean provides a mock function with given fields: column
func (_m *Blueprint) Boolean(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Boolean")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Boolean_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Boolean'
type Blueprint_Boolean_Call struct {
	*mock.Call
}

// Boolean is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Boolean(column interface{}) *Blueprint_Boolean_Call {
	return &Blueprint_Boolean_Call{Call: _e.mock.On("Boolean", column)}
}

func (_c *Blueprint_Boolean_Call) Run(run func(column string)) *Blueprint_Boolean_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Boolean_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Boolean_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Boolean_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Boolean_Call {
	_c.Call.Return(run)
	return _c
}

// Build provides a mock function with given fields: query, grammar
func (_m *Blueprint) Build(query orm.Query, grammar schema.Grammar) error {
	ret := _m.Called(query, grammar)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(orm.Query, schema.Grammar) error); ok {
		r0 = rf(query, grammar)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Blueprint_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type Blueprint_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - query orm.Query
//   - grammar schema.Grammar
func (_e *Blueprint_Expecter) Build(query interface{}, grammar interface{}) *Blueprint_Build_Call {
	return &Blueprint_Build_Call{Call: _e.mock.On("Build", query, grammar)}
}

func (_c *Blueprint_Build_Call) Run(run func(query orm.Query, grammar schema.Grammar)) *Blueprint_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(orm.Query), args[1].(schema.Grammar))
	})
	return _c
}

func (_c *Blueprint_Build_Call) Return(_a0 error) *Blueprint_Build_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Build_Call) RunAndReturn(run func(orm.Query, schema.Grammar) error) *Blueprint_Build_Call {
	_c.Call.Return(run)
	return _c
}

// Char provides a mock function with given fields: column, length
func (_m *Blueprint) Char(column string, length ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Char")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Char_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Char'
type Blueprint_Char_Call struct {
	*mock.Call
}

// Char is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) Char(column interface{}, length ...interface{}) *Blueprint_Char_Call {
	return &Blueprint_Char_Call{Call: _e.mock.On("Char",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_Char_Call) Run(run func(column string, length ...int)) *Blueprint_Char_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Char_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Char_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Char_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_Char_Call {
	_c.Call.Return(run)
	return _c
}

// Comment provides a mock function with given fields: comment
func (_m *Blueprint) Comment(comment string) {
	_m.Called(comment)
}

// Blueprint_Comment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Comment'
type Blueprint_Comment_Call struct {
	*mock.Call
}

// Comment is a helper method to define mock.On call
//   - comment string
func (_e *Blueprint_Expecter) Comment(comment interface{}) *Blueprint_Comment_Call {
	return &Blueprint_Comment_Call{Call: _e.mock.On("Comment", comment)}
}

func (_c *Blueprint_Comment_Call) Run(run func(comment string)) *Blueprint_Comment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Comment_Call) Return() *Blueprint_Comment_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Comment_Call) RunAndReturn(run func(string)) *Blueprint_Comment_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields:
func (_m *Blueprint) Create() {
	_m.Called()
}

// Blueprint_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Blueprint_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
func (_e *Blueprint_Expecter) Create() *Blueprint_Create_Call {
	return &Blueprint_Create_Call{Call: _e.mock.On("Create")}
}

func (_c *Blueprint_Create_Call) Run(run func()) *Blueprint_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_Create_Call) Return() *Blueprint_Create_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Create_Call) RunAndReturn(run func()) *Blueprint_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Date provides a mock function with given fields: column
func (_m *Blueprint) Date(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Date")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Date_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Date'
type Blueprint_Date_Call struct {
	*mock.Call
}

// Date is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Date(column interface{}) *Blueprint_Date_Call {
	return &Blueprint_Date_Call{Call: _e.mock.On("Date", column)}
}

func (_c *Blueprint_Date_Call) Run(run func(column string)) *Blueprint_Date_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Date_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Date_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Date_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Date_Call {
	_c.Call.Return(run)
	return _c
}

// DateTime provides a mock function with given fields: column, precision
func (_m *Blueprint) DateTime(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DateTime")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_DateTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DateTime'
type Blueprint_DateTime_Call struct {
	*mock.Call
}

// DateTime is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) DateTime(column interface{}, precision ...interface{}) *Blueprint_DateTime_Call {
	return &Blueprint_DateTime_Call{Call: _e.mock.On("DateTime",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_DateTime_Call) Run(run func(column string, precision ...int)) *Blueprint_DateTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DateTime_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_DateTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_DateTime_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_DateTime_Call {
	_c.Call.Return(run)
	return _c
}

// DateTimeTz provides a mock function with given fields: column, precision
func (_m *Blueprint) DateTimeTz(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DateTimeTz")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_DateTimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DateTimeTz'
type Blueprint_DateTimeTz_Call struct {
	*mock.Call
}

// DateTimeTz is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) DateTimeTz(column interface{}, precision ...interface{}) *Blueprint_DateTimeTz_Call {
	return &Blueprint_DateTimeTz_Call{Call: _e.mock.On("DateTimeTz",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_DateTimeTz_Call) Run(run func(column string, precision ...int)) *Blueprint_DateTimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DateTimeTz_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_DateTimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_DateTimeTz_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_DateTimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// Decimal provides a mock function with given fields: column, length
func (_m *Blueprint) Decimal(column string, length ...schema.DecimalConfig) schema.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Decimal")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...schema.DecimalConfig) schema.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Decimal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decimal'
type Blueprint_Decimal_Call struct {
	*mock.Call
}

// Decimal is a helper method to define mock.On call
//   - column string
//   - length ...schema.DecimalConfig
func (_e *Blueprint_Expecter) Decimal(column interface{}, length ...interface{}) *Blueprint_Decimal_Call {
	return &Blueprint_Decimal_Call{Call: _e.mock.On("Decimal",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_Decimal_Call) Run(run func(column string, length ...schema.DecimalConfig)) *Blueprint_Decimal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]schema.DecimalConfig, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(schema.DecimalConfig)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Decimal_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Decimal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Decimal_Call) RunAndReturn(run func(string, ...schema.DecimalConfig) schema.ColumnDefinition) *Blueprint_Decimal_Call {
	_c.Call.Return(run)
	return _c
}

// Double provides a mock function with given fields: column
func (_m *Blueprint) Double(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Double")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Double_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Double'
type Blueprint_Double_Call struct {
	*mock.Call
}

// Double is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Double(column interface{}) *Blueprint_Double_Call {
	return &Blueprint_Double_Call{Call: _e.mock.On("Double", column)}
}

func (_c *Blueprint_Double_Call) Run(run func(column string)) *Blueprint_Double_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Double_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Double_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Double_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Double_Call {
	_c.Call.Return(run)
	return _c
}

// DropColumn provides a mock function with given fields: column
func (_m *Blueprint) DropColumn(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropColumn'
type Blueprint_DropColumn_Call struct {
	*mock.Call
}

// DropColumn is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropColumn(column ...interface{}) *Blueprint_DropColumn_Call {
	return &Blueprint_DropColumn_Call{Call: _e.mock.On("DropColumn",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropColumn_Call) Run(run func(column ...string)) *Blueprint_DropColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropColumn_Call) Return() *Blueprint_DropColumn_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropColumn_Call) RunAndReturn(run func(...string)) *Blueprint_DropColumn_Call {
	_c.Call.Return(run)
	return _c
}

// DropForeign provides a mock function with given fields: columns
func (_m *Blueprint) DropForeign(columns []string) {
	_m.Called(columns)
}

// Blueprint_DropForeign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropForeign'
type Blueprint_DropForeign_Call struct {
	*mock.Call
}

// DropForeign is a helper method to define mock.On call
//   - columns []string
func (_e *Blueprint_Expecter) DropForeign(columns interface{}) *Blueprint_DropForeign_Call {
	return &Blueprint_DropForeign_Call{Call: _e.mock.On("DropForeign", columns)}
}

func (_c *Blueprint_DropForeign_Call) Run(run func(columns []string)) *Blueprint_DropForeign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string))
	})
	return _c
}

func (_c *Blueprint_DropForeign_Call) Return() *Blueprint_DropForeign_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropForeign_Call) RunAndReturn(run func([]string)) *Blueprint_DropForeign_Call {
	_c.Call.Return(run)
	return _c
}

// DropForeignByName provides a mock function with given fields: name
func (_m *Blueprint) DropForeignByName(name string) {
	_m.Called(name)
}

// Blueprint_DropForeignByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropForeignByName'
type Blueprint_DropForeignByName_Call struct {
	*mock.Call
}

// DropForeignByName is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) DropForeignByName(name interface{}) *Blueprint_DropForeignByName_Call {
	return &Blueprint_DropForeignByName_Call{Call: _e.mock.On("DropForeignByName", name)}
}

func (_c *Blueprint_DropForeignByName_Call) Run(run func(name string)) *Blueprint_DropForeignByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_DropForeignByName_Call) Return() *Blueprint_DropForeignByName_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropForeignByName_Call) RunAndReturn(run func(string)) *Blueprint_DropForeignByName_Call {
	_c.Call.Return(run)
	return _c
}

// DropIfExists provides a mock function with given fields:
func (_m *Blueprint) DropIfExists() {
	_m.Called()
}

// Blueprint_DropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIfExists'
type Blueprint_DropIfExists_Call struct {
	*mock.Call
}

// DropIfExists is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropIfExists() *Blueprint_DropIfExists_Call {
	return &Blueprint_DropIfExists_Call{Call: _e.mock.On("DropIfExists")}
}

func (_c *Blueprint_DropIfExists_Call) Run(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropIfExists_Call) Return() *Blueprint_DropIfExists_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIfExists_Call) RunAndReturn(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// DropIndex provides a mock function with given fields: columns
func (_m *Blueprint) DropIndex(columns []string) {
	_m.Called(columns)
}

// Blueprint_DropIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIndex'
type Blueprint_DropIndex_Call struct {
	*mock.Call
}

// DropIndex is a helper method to define mock.On call
//   - columns []string
func (_e *Blueprint_Expecter) DropIndex(columns interface{}) *Blueprint_DropIndex_Call {
	return &Blueprint_DropIndex_Call{Call: _e.mock.On("DropIndex", columns)}
}

func (_c *Blueprint_DropIndex_Call) Run(run func(columns []string)) *Blueprint_DropIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string))
	})
	return _c
}

func (_c *Blueprint_DropIndex_Call) Return() *Blueprint_DropIndex_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIndex_Call) RunAndReturn(run func([]string)) *Blueprint_DropIndex_Call {
	_c.Call.Return(run)
	return _c
}

// DropIndexByName provides a mock function with given fields: name
func (_m *Blueprint) DropIndexByName(name string) {
	_m.Called(name)
}

// Blueprint_DropIndexByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIndexByName'
type Blueprint_DropIndexByName_Call struct {
	*mock.Call
}

// DropIndexByName is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) DropIndexByName(name interface{}) *Blueprint_DropIndexByName_Call {
	return &Blueprint_DropIndexByName_Call{Call: _e.mock.On("DropIndexByName", name)}
}

func (_c *Blueprint_DropIndexByName_Call) Run(run func(name string)) *Blueprint_DropIndexByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_DropIndexByName_Call) Return() *Blueprint_DropIndexByName_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIndexByName_Call) RunAndReturn(run func(string)) *Blueprint_DropIndexByName_Call {
	_c.Call.Return(run)
	return _c
}

// DropSoftDeletes provides a mock function with given fields: column
func (_m *Blueprint) DropSoftDeletes(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropSoftDeletes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropSoftDeletes'
type Blueprint_DropSoftDeletes_Call struct {
	*mock.Call
}

// DropSoftDeletes is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropSoftDeletes(column ...interface{}) *Blueprint_DropSoftDeletes_Call {
	return &Blueprint_DropSoftDeletes_Call{Call: _e.mock.On("DropSoftDeletes",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropSoftDeletes_Call) Run(run func(column ...string)) *Blueprint_DropSoftDeletes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropSoftDeletes_Call) Return() *Blueprint_DropSoftDeletes_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropSoftDeletes_Call) RunAndReturn(run func(...string)) *Blueprint_DropSoftDeletes_Call {
	_c.Call.Return(run)
	return _c
}

// DropSoftDeletesTz provides a mock function with given fields: column
func (_m *Blueprint) DropSoftDeletesTz(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_DropSoftDeletesTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropSoftDeletesTz'
type Blueprint_DropSoftDeletesTz_Call struct {
	*mock.Call
}

// DropSoftDeletesTz is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) DropSoftDeletesTz(column ...interface{}) *Blueprint_DropSoftDeletesTz_Call {
	return &Blueprint_DropSoftDeletesTz_Call{Call: _e.mock.On("DropSoftDeletesTz",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_DropSoftDeletesTz_Call) Run(run func(column ...string)) *Blueprint_DropSoftDeletesTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_DropSoftDeletesTz_Call) Return() *Blueprint_DropSoftDeletesTz_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropSoftDeletesTz_Call) RunAndReturn(run func(...string)) *Blueprint_DropSoftDeletesTz_Call {
	_c.Call.Return(run)
	return _c
}

// DropTimestamps provides a mock function with given fields:
func (_m *Blueprint) DropTimestamps() {
	_m.Called()
}

// Blueprint_DropTimestamps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropTimestamps'
type Blueprint_DropTimestamps_Call struct {
	*mock.Call
}

// DropTimestamps is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropTimestamps() *Blueprint_DropTimestamps_Call {
	return &Blueprint_DropTimestamps_Call{Call: _e.mock.On("DropTimestamps")}
}

func (_c *Blueprint_DropTimestamps_Call) Run(run func()) *Blueprint_DropTimestamps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropTimestamps_Call) Return() *Blueprint_DropTimestamps_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropTimestamps_Call) RunAndReturn(run func()) *Blueprint_DropTimestamps_Call {
	_c.Call.Return(run)
	return _c
}

// DropTimestampsTz provides a mock function with given fields:
func (_m *Blueprint) DropTimestampsTz() {
	_m.Called()
}

// Blueprint_DropTimestampsTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropTimestampsTz'
type Blueprint_DropTimestampsTz_Call struct {
	*mock.Call
}

// DropTimestampsTz is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropTimestampsTz() *Blueprint_DropTimestampsTz_Call {
	return &Blueprint_DropTimestampsTz_Call{Call: _e.mock.On("DropTimestampsTz")}
}

func (_c *Blueprint_DropTimestampsTz_Call) Run(run func()) *Blueprint_DropTimestampsTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropTimestampsTz_Call) Return() *Blueprint_DropTimestampsTz_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropTimestampsTz_Call) RunAndReturn(run func()) *Blueprint_DropTimestampsTz_Call {
	_c.Call.Return(run)
	return _c
}

// Enum provides a mock function with given fields: column, array
func (_m *Blueprint) Enum(column string, array []string) schema.ColumnDefinition {
	ret := _m.Called(column, array)

	if len(ret) == 0 {
		panic("no return value specified for Enum")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, []string) schema.ColumnDefinition); ok {
		r0 = rf(column, array)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Enum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enum'
type Blueprint_Enum_Call struct {
	*mock.Call
}

// Enum is a helper method to define mock.On call
//   - column string
//   - array []string
func (_e *Blueprint_Expecter) Enum(column interface{}, array interface{}) *Blueprint_Enum_Call {
	return &Blueprint_Enum_Call{Call: _e.mock.On("Enum", column, array)}
}

func (_c *Blueprint_Enum_Call) Run(run func(column string, array []string)) *Blueprint_Enum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]string))
	})
	return _c
}

func (_c *Blueprint_Enum_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Enum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Enum_Call) RunAndReturn(run func(string, []string) schema.ColumnDefinition) *Blueprint_Enum_Call {
	_c.Call.Return(run)
	return _c
}

// Float provides a mock function with given fields: column, precision
func (_m *Blueprint) Float(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Float")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Float_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Float'
type Blueprint_Float_Call struct {
	*mock.Call
}

// Float is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Float(column interface{}, precision ...interface{}) *Blueprint_Float_Call {
	return &Blueprint_Float_Call{Call: _e.mock.On("Float",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Float_Call) Run(run func(column string, precision ...int)) *Blueprint_Float_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Float_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Float_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Float_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_Float_Call {
	_c.Call.Return(run)
	return _c
}

// Foreign provides a mock function with given fields: columns, name
func (_m *Blueprint) Foreign(columns []string, name ...string) schema.ForeignKeyDefinition {
	_va := make([]interface{}, len(name))
	for _i := range name {
		_va[_i] = name[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, columns)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Foreign")
	}

	var r0 schema.ForeignKeyDefinition
	if rf, ok := ret.Get(0).(func([]string, ...string) schema.ForeignKeyDefinition); ok {
		r0 = rf(columns, name...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ForeignKeyDefinition)
		}
	}

	return r0
}

// Blueprint_Foreign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Foreign'
type Blueprint_Foreign_Call struct {
	*mock.Call
}

// Foreign is a helper method to define mock.On call
//   - columns []string
//   - name ...string
func (_e *Blueprint_Expecter) Foreign(columns interface{}, name ...interface{}) *Blueprint_Foreign_Call {
	return &Blueprint_Foreign_Call{Call: _e.mock.On("Foreign",
		append([]interface{}{columns}, name...)...)}
}

func (_c *Blueprint_Foreign_Call) Run(run func(columns []string, name ...string)) *Blueprint_Foreign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Foreign_Call) Return(_a0 schema.ForeignKeyDefinition) *Blueprint_Foreign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Foreign_Call) RunAndReturn(run func([]string, ...string) schema.ForeignKeyDefinition) *Blueprint_Foreign_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddedColumns provides a mock function with given fields:
func (_m *Blueprint) GetAddedColumns() []schema.ColumnDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddedColumns")
	}

	var r0 []schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func() []schema.ColumnDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_GetAddedColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddedColumns'
type Blueprint_GetAddedColumns_Call struct {
	*mock.Call
}

// GetAddedColumns is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetAddedColumns() *Blueprint_GetAddedColumns_Call {
	return &Blueprint_GetAddedColumns_Call{Call: _e.mock.On("GetAddedColumns")}
}

func (_c *Blueprint_GetAddedColumns_Call) Run(run func()) *Blueprint_GetAddedColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) Return(_a0 []schema.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) RunAndReturn(run func() []schema.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(run)
	return _c
}

// GetChangedColumns provides a mock function with given fields:
func (_m *Blueprint) GetChangedColumns() []schema.ColumnDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetChangedColumns")
	}

	var r0 []schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func() []schema.ColumnDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_GetChangedColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChangedColumns'
type Blueprint_GetChangedColumns_Call struct {
	*mock.Call
}

// GetChangedColumns is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetChangedColumns() *Blueprint_GetChangedColumns_Call {
	return &Blueprint_GetChangedColumns_Call{Call: _e.mock.On("GetChangedColumns")}
}

func (_c *Blueprint_GetChangedColumns_Call) Run(run func()) *Blueprint_GetChangedColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetChangedColumns_Call) Return(_a0 []schema.ColumnDefinition) *Blueprint_GetChangedColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetChangedColumns_Call) RunAndReturn(run func() []schema.ColumnDefinition) *Blueprint_GetChangedColumns_Call {
	_c.Call.Return(run)
	return _c
}

// GetPrefix provides a mock function with given fields:
func (_m *Blueprint) GetPrefix() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPrefix")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Blueprint_GetPrefix_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPrefix'
type Blueprint_GetPrefix_Call struct {
	*mock.Call
}

// GetPrefix is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetPrefix() *Blueprint_GetPrefix_Call {
	return &Blueprint_GetPrefix_Call{Call: _e.mock.On("GetPrefix")}
}

func (_c *Blueprint_GetPrefix_Call) Run(run func()) *Blueprint_GetPrefix_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetPrefix_Call) Return(_a0 string) *Blueprint_GetPrefix_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetPrefix_Call) RunAndReturn(run func() string) *Blueprint_GetPrefix_Call {
	_c.Call.Return(run)
	return _c
}

// GetTableName provides a mock function with given fields:
func (_m *Blueprint) GetTableName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTableName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Blueprint_GetTableName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTableName'
type Blueprint_GetTableName_Call struct {
	*mock.Call
}

// GetTableName is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetTableName() *Blueprint_GetTableName_Call {
	return &Blueprint_GetTableName_Call{Call: _e.mock.On("GetTableName")}
}

func (_c *Blueprint_GetTableName_Call) Run(run func()) *Blueprint_GetTableName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetTableName_Call) Return(_a0 string) *Blueprint_GetTableName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetTableName_Call) RunAndReturn(run func() string) *Blueprint_GetTableName_Call {
	_c.Call.Return(run)
	return _c
}

// HasCommand provides a mock function with given fields: command
func (_m *Blueprint) HasCommand(command string) bool {
	ret := _m.Called(command)

	if len(ret) == 0 {
		panic("no return value specified for HasCommand")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(command)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Blueprint_HasCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCommand'
type Blueprint_HasCommand_Call struct {
	*mock.Call
}

// HasCommand is a helper method to define mock.On call
//   - command string
func (_e *Blueprint_Expecter) HasCommand(command interface{}) *Blueprint_HasCommand_Call {
	return &Blueprint_HasCommand_Call{Call: _e.mock.On("HasCommand", command)}
}

func (_c *Blueprint_HasCommand_Call) Run(run func(command string)) *Blueprint_HasCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_HasCommand_Call) Return(_a0 bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_HasCommand_Call) RunAndReturn(run func(string) bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function with given fields: column
func (_m *Blueprint) ID(column ...string) schema.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Blueprint_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) ID(column ...interface{}) *Blueprint_ID_Call {
	return &Blueprint_ID_Call{Call: _e.mock.On("ID",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_ID_Call) Run(run func(column ...string)) *Blueprint_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_ID_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ID_Call) RunAndReturn(run func(...string) schema.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function with given fields: columns, config
func (_m *Blueprint) Index(columns []string, config ...schema.IndexConfig) {
	_va := make([]interface{}, len(config))
	for _i := range config {
		_va[_i] = config[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, columns)
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type Blueprint_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - columns []string
//   - config ...schema.IndexConfig
func (_e *Blueprint_Expecter) Index(columns interface{}, config ...interface{}) *Blueprint_Index_Call {
	return &Blueprint_Index_Call{Call: _e.mock.On("Index",
		append([]interface{}{columns}, config...)...)}
}

func (_c *Blueprint_Index_Call) Run(run func(columns []string, config ...schema.IndexConfig)) *Blueprint_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]schema.IndexConfig, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(schema.IndexConfig)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Index_Call) Return() *Blueprint_Index_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Index_Call) RunAndReturn(run func([]string, ...schema.IndexConfig)) *Blueprint_Index_Call {
	_c.Call.Return(run)
	return _c
}

// Integer provides a mock function with given fields: column, config
func (_m *Blueprint) Integer(column string, config ...schema.IntegerConfig) schema.ColumnDefinition {
	_va := make([]interface{}, len(config))
	for _i := range config {
		_va[_i] = config[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Integer")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...schema.IntegerConfig) schema.ColumnDefinition); ok {
		r0 = rf(column, config...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Integer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Integer'
type Blueprint_Integer_Call struct {
	*mock.Call
}

// Integer is a helper method to define mock.On call
//   - column string
//   - config ...schema.IntegerConfig
func (_e *Blueprint_Expecter) Integer(column interface{}, config ...interface{}) *Blueprint_Integer_Call {
	return &Blueprint_Integer_Call{Call: _e.mock.On("Integer",
		append([]interface{}{column}, config...)...)}
}

func (_c *Blueprint_Integer_Call) Run(run func(column string, config ...schema.IntegerConfig)) *Blueprint_Integer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]schema.IntegerConfig, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(schema.IntegerConfig)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Integer_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Integer_Call) RunAndReturn(run func(string, ...schema.IntegerConfig) schema.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(run)
	return _c
}

// Json provides a mock function with given fields: column
func (_m *Blueprint) Json(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Json")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Json_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Json'
type Blueprint_Json_Call struct {
	*mock.Call
}

// Json is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Json(column interface{}) *Blueprint_Json_Call {
	return &Blueprint_Json_Call{Call: _e.mock.On("Json", column)}
}

func (_c *Blueprint_Json_Call) Run(run func(column string)) *Blueprint_Json_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Json_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Json_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Json_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Json_Call {
	_c.Call.Return(run)
	return _c
}

// Jsonb provides a mock function with given fields: column
func (_m *Blueprint) Jsonb(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Jsonb")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Jsonb_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Jsonb'
type Blueprint_Jsonb_Call struct {
	*mock.Call
}

// Jsonb is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Jsonb(column interface{}) *Blueprint_Jsonb_Call {
	return &Blueprint_Jsonb_Call{Call: _e.mock.On("Jsonb", column)}
}

func (_c *Blueprint_Jsonb_Call) Run(run func(column string)) *Blueprint_Jsonb_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Jsonb_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Jsonb_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Jsonb_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Jsonb_Call {
	_c.Call.Return(run)
	return _c
}

// Primary provides a mock function with given fields: columns
func (_m *Blueprint) Primary(columns []string) {
	_m.Called(columns)
}

// Blueprint_Primary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Primary'
type Blueprint_Primary_Call struct {
	*mock.Call
}

// Primary is a helper method to define mock.On call
//   - columns []string
func (_e *Blueprint_Expecter) Primary(columns interface{}) *Blueprint_Primary_Call {
	return &Blueprint_Primary_Call{Call: _e.mock.On("Primary", columns)}
}

func (_c *Blueprint_Primary_Call) Run(run func(columns []string)) *Blueprint_Primary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string))
	})
	return _c
}

func (_c *Blueprint_Primary_Call) Return() *Blueprint_Primary_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Primary_Call) RunAndReturn(run func([]string)) *Blueprint_Primary_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: to
func (_m *Blueprint) Rename(to string) {
	_m.Called(to)
}

// Blueprint_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type Blueprint_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - to string
func (_e *Blueprint_Expecter) Rename(to interface{}) *Blueprint_Rename_Call {
	return &Blueprint_Rename_Call{Call: _e.mock.On("Rename", to)}
}

func (_c *Blueprint_Rename_Call) Run(run func(to string)) *Blueprint_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Rename_Call) Return() *Blueprint_Rename_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Rename_Call) RunAndReturn(run func(string)) *Blueprint_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// RenameColumn provides a mock function with given fields: from, to
func (_m *Blueprint) RenameColumn(from string, to string) {
	_m.Called(from, to)
}

// Blueprint_RenameColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameColumn'
type Blueprint_RenameColumn_Call struct {
	*mock.Call
}

// RenameColumn is a helper method to define mock.On call
//   - from string
//   - to string
func (_e *Blueprint_Expecter) RenameColumn(from interface{}, to interface{}) *Blueprint_RenameColumn_Call {
	return &Blueprint_RenameColumn_Call{Call: _e.mock.On("RenameColumn", from, to)}
}

func (_c *Blueprint_RenameColumn_Call) Run(run func(from string, to string)) *Blueprint_RenameColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Blueprint_RenameColumn_Call) Return() *Blueprint_RenameColumn_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_RenameColumn_Call) RunAndReturn(run func(string, string)) *Blueprint_RenameColumn_Call {
	_c.Call.Return(run)
	return _c
}

// RenameIndex provides a mock function with given fields: from, to
func (_m *Blueprint) RenameIndex(from string, to string) {
	_m.Called(from, to)
}

// Blueprint_RenameIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameIndex'
type Blueprint_RenameIndex_Call struct {
	*mock.Call
}

// RenameIndex is a helper method to define mock.On call
//   - from string
//   - to string
func (_e *Blueprint_Expecter) RenameIndex(from interface{}, to interface{}) *Blueprint_RenameIndex_Call {
	return &Blueprint_RenameIndex_Call{Call: _e.mock.On("RenameIndex", from, to)}
}

func (_c *Blueprint_RenameIndex_Call) Run(run func(from string, to string)) *Blueprint_RenameIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Blueprint_RenameIndex_Call) Return() *Blueprint_RenameIndex_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_RenameIndex_Call) RunAndReturn(run func(string, string)) *Blueprint_RenameIndex_Call {
	_c.Call.Return(run)
	return _c
}

// SoftDeletes provides a mock function with given fields: column
func (_m *Blueprint) SoftDeletes(column ...string) schema.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftDeletes")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SoftDeletes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SoftDeletes'
type Blueprint_SoftDeletes_Call struct {
	*mock.Call
}

// SoftDeletes is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) SoftDeletes(column ...interface{}) *Blueprint_SoftDeletes_Call {
	return &Blueprint_SoftDeletes_Call{Call: _e.mock.On("SoftDeletes",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_SoftDeletes_Call) Run(run func(column ...string)) *Blueprint_SoftDeletes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_SoftDeletes_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_SoftDeletes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SoftDeletes_Call) RunAndReturn(run func(...string) schema.ColumnDefinition) *Blueprint_SoftDeletes_Call {
	_c.Call.Return(run)
	return _c
}

// SoftDeletesTz provides a mock function with given fields: column
func (_m *Blueprint) SoftDeletesTz(column ...string) schema.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SoftDeletesTz")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SoftDeletesTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SoftDeletesTz'
type Blueprint_SoftDeletesTz_Call struct {
	*mock.Call
}

// SoftDeletesTz is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) SoftDeletesTz(column ...interface{}) *Blueprint_SoftDeletesTz_Call {
	return &Blueprint_SoftDeletesTz_Call{Call: _e.mock.On("SoftDeletesTz",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_SoftDeletesTz_Call) Run(run func(column ...string)) *Blueprint_SoftDeletesTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_SoftDeletesTz_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_SoftDeletesTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SoftDeletesTz_Call) RunAndReturn(run func(...string) schema.ColumnDefinition) *Blueprint_SoftDeletesTz_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields: column, length
func (_m *Blueprint) String(column string, length ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Blueprint_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) String(column interface{}, length ...interface{}) *Blueprint_String_Call {
	return &Blueprint_String_Call{Call: _e.mock.On("String",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_String_Call) Run(run func(column string, length ...int)) *Blueprint_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_String_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_String_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(run)
	return _c
}

// Text provides a mock function with given fields: column
func (_m *Blueprint) Text(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Text")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Text_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Text'
type Blueprint_Text_Call struct {
	*mock.Call
}

// Text is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Text(column interface{}) *Blueprint_Text_Call {
	return &Blueprint_Text_Call{Call: _e.mock.On("Text", column)}
}

func (_c *Blueprint_Text_Call) Run(run func(column string)) *Blueprint_Text_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Text_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Text_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Text_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Text_Call {
	_c.Call.Return(run)
	return _c
}

// Time provides a mock function with given fields: column, precision
func (_m *Blueprint) Time(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Time_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Time'
type Blueprint_Time_Call struct {
	*mock.Call
}

// Time is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Time(column interface{}, precision ...interface{}) *Blueprint_Time_Call {
	return &Blueprint_Time_Call{Call: _e.mock.On("Time",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Time_Call) Run(run func(column string, precision ...int)) *Blueprint_Time_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Time_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Time_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Time_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_Time_Call {
	_c.Call.Return(run)
	return _c
}

// TimeTz provides a mock function with given fields: column, precision
func (_m *Blueprint) TimeTz(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimeTz")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimeTz'
type Blueprint_TimeTz_Call struct {
	*mock.Call
}

// TimeTz is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) TimeTz(column interface{}, precision ...interface{}) *Blueprint_TimeTz_Call {
	return &Blueprint_TimeTz_Call{Call: _e.mock.On("TimeTz",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_TimeTz_Call) Run(run func(column string, precision ...int)) *Blueprint_TimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_TimeTz_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_TimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TimeTz_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_TimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// Timestamp provides a mock function with given fields: column, precision
func (_m *Blueprint) Timestamp(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Timestamp")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Timestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Timestamp'
type Blueprint_Timestamp_Call struct {
	*mock.Call
}

// Timestamp is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Timestamp(column interface{}, precision ...interface{}) *Blueprint_Timestamp_Call {
	return &Blueprint_Timestamp_Call{Call: _e.mock.On("Timestamp",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Timestamp_Call) Run(run func(column string, precision ...int)) *Blueprint_Timestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Timestamp_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Timestamp_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Timestamp_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_Timestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TimestampTz provides a mock function with given fields: column, precision
func (_m *Blueprint) TimestampTz(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TimestampTz")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TimestampTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimestampTz'
type Blueprint_TimestampTz_Call struct {
	*mock.Call
}

// TimestampTz is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) TimestampTz(column interface{}, precision ...interface{}) *Blueprint_TimestampTz_Call {
	return &Blueprint_TimestampTz_Call{Call: _e.mock.On("TimestampTz",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_TimestampTz_Call) Run(run func(column string, precision ...int)) *Blueprint_TimestampTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_TimestampTz_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_TimestampTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TimestampTz_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_TimestampTz_Call {
	_c.Call.Return(run)
	return _c
}

// Timestamps provides a mock function with given fields: precision
func (_m *Blueprint) Timestamps(precision ...int) {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_Timestamps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Timestamps'
type Blueprint_Timestamps_Call struct {
	*mock.Call
}

// Timestamps is a helper method to define mock.On call
//   - precision ...int
func (_e *Blueprint_Expecter) Timestamps(precision ...interface{}) *Blueprint_Timestamps_Call {
	return &Blueprint_Timestamps_Call{Call: _e.mock.On("Timestamps",
		append([]interface{}{}, precision...)...)}
}

func (_c *Blueprint_Timestamps_Call) Run(run func(precision ...int)) *Blueprint_Timestamps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Timestamps_Call) Return() *Blueprint_Timestamps_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Timestamps_Call) RunAndReturn(run func(...int)) *Blueprint_Timestamps_Call {
	_c.Call.Return(run)
	return _c
}

// TimestampsTz provides a mock function with given fields: precision
func (_m *Blueprint) TimestampsTz(precision ...int) {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_TimestampsTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimestampsTz'
type Blueprint_TimestampsTz_Call struct {
	*mock.Call
}

// TimestampsTz is a helper method to define mock.On call
//   - precision ...int
func (_e *Blueprint_Expecter) TimestampsTz(precision ...interface{}) *Blueprint_TimestampsTz_Call {
	return &Blueprint_TimestampsTz_Call{Call: _e.mock.On("TimestampsTz",
		append([]interface{}{}, precision...)...)}
}

func (_c *Blueprint_TimestampsTz_Call) Run(run func(precision ...int)) *Blueprint_TimestampsTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_TimestampsTz_Call) Return() *Blueprint_TimestampsTz_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_TimestampsTz_Call) RunAndReturn(run func(...int)) *Blueprint_TimestampsTz_Call {
	_c.Call.Return(run)
	return _c
}

// ToSql provides a mock function with given fields: query, grammar
func (_m *Blueprint) ToSql(query orm.Query, grammar schema.Grammar) []string {
	ret := _m.Called(query, grammar)

	if len(ret) == 0 {
		panic("no return value specified for ToSql")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(orm.Query, schema.Grammar) []string); ok {
		r0 = rf(query, grammar)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Blueprint_ToSql_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToSql'
type Blueprint_ToSql_Call struct {
	*mock.Call
}

// ToSql is a helper method to define mock.On call
//   - query orm.Query
//   - grammar schema.Grammar
func (_e *Blueprint_Expecter) ToSql(query interface{}, grammar interface{}) *Blueprint_ToSql_Call {
	return &Blueprint_ToSql_Call{Call: _e.mock.On("ToSql", query, grammar)}
}

func (_c *Blueprint_ToSql_Call) Run(run func(query orm.Query, grammar schema.Grammar)) *Blueprint_ToSql_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(orm.Query), args[1].(schema.Grammar))
	})
	return _c
}

func (_c *Blueprint_ToSql_Call) Return(_a0 []string) *Blueprint_ToSql_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ToSql_Call) RunAndReturn(run func(orm.Query, schema.Grammar) []string) *Blueprint_ToSql_Call {
	_c.Call.Return(run)
	return _c
}

// Unique provides a mock function with given fields: columns
func (_m *Blueprint) Unique(columns []string) {
	_m.Called(columns)
}

// Blueprint_Unique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unique'
type Blueprint_Unique_Call struct {
	*mock.Call
}

// Unique is a helper method to define mock.On call
//   - columns []string
func (_e *Blueprint_Expecter) Unique(columns interface{}) *Blueprint_Unique_Call {
	return &Blueprint_Unique_Call{Call: _e.mock.On("Unique", columns)}
}

func (_c *Blueprint_Unique_Call) Run(run func(columns []string)) *Blueprint_Unique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string))
	})
	return _c
}

func (_c *Blueprint_Unique_Call) Return() *Blueprint_Unique_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Unique_Call) RunAndReturn(run func([]string)) *Blueprint_Unique_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedBigInteger provides a mock function with given fields: column, autoIncrement
func (_m *Blueprint) UnsignedBigInteger(column string, autoIncrement ...bool) schema.ColumnDefinition {
	_va := make([]interface{}, len(autoIncrement))
	for _i := range autoIncrement {
		_va[_i] = autoIncrement[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedBigInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...bool) schema.ColumnDefinition); ok {
		r0 = rf(column, autoIncrement...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedBigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedBigInteger'
type Blueprint_UnsignedBigInteger_Call struct {
	*mock.Call
}

// UnsignedBigInteger is a helper method to define mock.On call
//   - column string
//   - autoIncrement ...bool
func (_e *Blueprint_Expecter) UnsignedBigInteger(column interface{}, autoIncrement ...interface{}) *Blueprint_UnsignedBigInteger_Call {
	return &Blueprint_UnsignedBigInteger_Call{Call: _e.mock.On("UnsignedBigInteger",
		append([]interface{}{column}, autoIncrement...)...)}
}

func (_c *Blueprint_UnsignedBigInteger_Call) Run(run func(column string, autoIncrement ...bool)) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_UnsignedBigInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedBigInteger_Call) RunAndReturn(run func(string, ...bool) schema.ColumnDefinition) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedInteger provides a mock function with given fields: column, autoIncrement
func (_m *Blueprint) UnsignedInteger(column string, autoIncrement ...bool) schema.ColumnDefinition {
	_va := make([]interface{}, len(autoIncrement))
	for _i := range autoIncrement {
		_va[_i] = autoIncrement[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...bool) schema.ColumnDefinition); ok {
		r0 = rf(column, autoIncrement...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedInteger'
type Blueprint_UnsignedInteger_Call struct {
	*mock.Call
}

// UnsignedInteger is a helper method to define mock.On call
//   - column string
//   - autoIncrement ...bool
func (_e *Blueprint_Expecter) UnsignedInteger(column interface{}, autoIncrement ...interface{}) *Blueprint_UnsignedInteger_Call {
	return &Blueprint_UnsignedInteger_Call{Call: _e.mock.On("UnsignedInteger",
		append([]interface{}{column}, autoIncrement...)...)}
}

func (_c *Blueprint_UnsignedInteger_Call) Run(run func(column string, autoIncrement ...bool)) *Blueprint_UnsignedInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_UnsignedInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedInteger_Call) RunAndReturn(run func(string, ...bool) schema.ColumnDefinition) *Blueprint_UnsignedInteger_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlueprint creates a new instance of Blueprint. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlueprint(t interface {
	mock.TestingT
	Cleanup(func())
}) *Blueprint {
	mock := &Blueprint{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
