// Code generated by mockery. DO NOT EDIT.

package schema

import (
	orm "github.com/goravel/framework/contracts/database/orm"
	schema "github.com/goravel/framework/contracts/database/schema"
	mock "github.com/stretchr/testify/mock"
)

// Grammar is an autogenerated mock type for the Grammar type
type Grammar struct {
	mock.Mock
}

type Grammar_Expecter struct {
	mock *mock.Mock
}

func (_m *Grammar) EXPECT() *Grammar_Expecter {
	return &Grammar_Expecter{mock: &_m.Mock}
}

// CompileAdd provides a mock function with given fields: blueprint
func (_m *Grammar) CompileAdd(blueprint schema.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileAdd")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileAdd'
type Grammar_CompileAdd_Call struct {
	*mock.Call
}

// CompileAdd is a helper method to define mock.On call
//   - blueprint schema.Blueprint
func (_e *Grammar_Expecter) CompileAdd(blueprint interface{}) *Grammar_CompileAdd_Call {
	return &Grammar_CompileAdd_Call{Call: _e.mock.On("CompileAdd", blueprint)}
}

func (_c *Grammar_CompileAdd_Call) Run(run func(blueprint schema.Blueprint)) *Grammar_CompileAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileAdd_Call) Return(_a0 string) *Grammar_CompileAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileAdd_Call) RunAndReturn(run func(schema.Blueprint) string) *Grammar_CompileAdd_Call {
	_c.Call.Return(run)
	return _c
}

// CompileChange provides a mock function with given fields: blueprint
func (_m *Grammar) CompileChange(blueprint schema.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileChange")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileChange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileChange'
type Grammar_CompileChange_Call struct {
	*mock.Call
}

// CompileChange is a helper method to define mock.On call
//   - blueprint schema.Blueprint
func (_e *Grammar_Expecter) CompileChange(blueprint interface{}) *Grammar_CompileChange_Call {
	return &Grammar_CompileChange_Call{Call: _e.mock.On("CompileChange", blueprint)}
}

func (_c *Grammar_CompileChange_Call) Run(run func(blueprint schema.Blueprint)) *Grammar_CompileChange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileChange_Call) Return(_a0 string) *Grammar_CompileChange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileChange_Call) RunAndReturn(run func(schema.Blueprint) string) *Grammar_CompileChange_Call {
	_c.Call.Return(run)
	return _c
}

// CompileColumns provides a mock function with given fields: _a0, table
func (_m *Grammar) CompileColumns(_a0 string, table string) string {
	ret := _m.Called(_a0, table)

	if len(ret) == 0 {
		panic("no return value specified for CompileColumns")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(_a0, table)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileColumns'
type Grammar_CompileColumns_Call struct {
	*mock.Call
}

// CompileColumns is a helper method to define mock.On call
//   - _a0 string
//   - table string
func (_e *Grammar_Expecter) CompileColumns(_a0 interface{}, table interface{}) *Grammar_CompileColumns_Call {
	return &Grammar_CompileColumns_Call{Call: _e.mock.On("CompileColumns", _a0, table)}
}

func (_c *Grammar_CompileColumns_Call) Run(run func(_a0 string, table string)) *Grammar_CompileColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileColumns_Call) Return(_a0 string) *Grammar_CompileColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileColumns_Call) RunAndReturn(run func(string, string) string) *Grammar_CompileColumns_Call {
	_c.Call.Return(run)
	return _c
}

// CompileComment provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileComment(blueprint schema.Blueprint, command *schema.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileComment")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, *schema.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileComment'
type Grammar_CompileComment_Call struct {
	*mock.Call
}

// CompileComment is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command *schema.Command
func (_e *Grammar_Expecter) CompileComment(blueprint interface{}, command interface{}) *Grammar_CompileComment_Call {
	return &Grammar_CompileComment_Call{Call: _e.mock.On("CompileComment", blueprint, command)}
}

func (_c *Grammar_CompileComment_Call) Run(run func(blueprint schema.Blueprint, command *schema.Command)) *Grammar_CompileComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(*schema.Command))
	})
	return _c
}

func (_c *Grammar_CompileComment_Call) Return(_a0 string) *Grammar_CompileComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileComment_Call) RunAndReturn(run func(schema.Blueprint, *schema.Command) string) *Grammar_CompileComment_Call {
	_c.Call.Return(run)
	return _c
}

// CompileCreate provides a mock function with given fields: blueprint, query
func (_m *Grammar) CompileCreate(blueprint schema.Blueprint, query orm.Query) string {
	ret := _m.Called(blueprint, query)

	if len(ret) == 0 {
		panic("no return value specified for CompileCreate")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, orm.Query) string); ok {
		r0 = rf(blueprint, query)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileCreate'
type Grammar_CompileCreate_Call struct {
	*mock.Call
}

// CompileCreate is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - query orm.Query
func (_e *Grammar_Expecter) CompileCreate(blueprint interface{}, query interface{}) *Grammar_CompileCreate_Call {
	return &Grammar_CompileCreate_Call{Call: _e.mock.On("CompileCreate", blueprint, query)}
}

func (_c *Grammar_CompileCreate_Call) Run(run func(blueprint schema.Blueprint, query orm.Query)) *Grammar_CompileCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(orm.Query))
	})
	return _c
}

func (_c *Grammar_CompileCreate_Call) Return(_a0 string) *Grammar_CompileCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileCreate_Call) RunAndReturn(run func(schema.Blueprint, orm.Query) string) *Grammar_CompileCreate_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDrop provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDrop(blueprint schema.Blueprint, command string) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDrop")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDrop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDrop'
type Grammar_CompileDrop_Call struct {
	*mock.Call
}

// CompileDrop is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command string
func (_e *Grammar_Expecter) CompileDrop(blueprint interface{}, command interface{}) *Grammar_CompileDrop_Call {
	return &Grammar_CompileDrop_Call{Call: _e.mock.On("CompileDrop", blueprint, command)}
}

func (_c *Grammar_CompileDrop_Call) Run(run func(blueprint schema.Blueprint, command string)) *Grammar_CompileDrop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileDrop_Call) Return(_a0 string) *Grammar_CompileDrop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDrop_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileDrop_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropAllTables provides a mock function with given fields: tables
func (_m *Grammar) CompileDropAllTables(tables []string) string {
	ret := _m.Called(tables)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropAllTables")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func([]string) string); ok {
		r0 = rf(tables)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropAllTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropAllTables'
type Grammar_CompileDropAllTables_Call struct {
	*mock.Call
}

// CompileDropAllTables is a helper method to define mock.On call
//   - tables []string
func (_e *Grammar_Expecter) CompileDropAllTables(tables interface{}) *Grammar_CompileDropAllTables_Call {
	return &Grammar_CompileDropAllTables_Call{Call: _e.mock.On("CompileDropAllTables", tables)}
}

func (_c *Grammar_CompileDropAllTables_Call) Run(run func(tables []string)) *Grammar_CompileDropAllTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]string))
	})
	return _c
}

func (_c *Grammar_CompileDropAllTables_Call) Return(_a0 string) *Grammar_CompileDropAllTables_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropAllTables_Call) RunAndReturn(run func([]string) string) *Grammar_CompileDropAllTables_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropColumn provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropColumn(blueprint schema.Blueprint, command *schema.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropColumn")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, *schema.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropColumn'
type Grammar_CompileDropColumn_Call struct {
	*mock.Call
}

// CompileDropColumn is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command *schema.Command
func (_e *Grammar_Expecter) CompileDropColumn(blueprint interface{}, command interface{}) *Grammar_CompileDropColumn_Call {
	return &Grammar_CompileDropColumn_Call{Call: _e.mock.On("CompileDropColumn", blueprint, command)}
}

func (_c *Grammar_CompileDropColumn_Call) Run(run func(blueprint schema.Blueprint, command *schema.Command)) *Grammar_CompileDropColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(*schema.Command))
	})
	return _c
}

func (_c *Grammar_CompileDropColumn_Call) Return(_a0 string) *Grammar_CompileDropColumn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropColumn_Call) RunAndReturn(run func(schema.Blueprint, *schema.Command) string) *Grammar_CompileDropColumn_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropForeign provides a mock function with given fields: blueprint, index
func (_m *Grammar) CompileDropForeign(blueprint schema.Blueprint, index string) string {
	ret := _m.Called(blueprint, index)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropForeign")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropForeign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropForeign'
type Grammar_CompileDropForeign_Call struct {
	*mock.Call
}

// CompileDropForeign is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - index string
func (_e *Grammar_Expecter) CompileDropForeign(blueprint interface{}, index interface{}) *Grammar_CompileDropForeign_Call {
	return &Grammar_CompileDropForeign_Call{Call: _e.mock.On("CompileDropForeign", blueprint, index)}
}

func (_c *Grammar_CompileDropForeign_Call) Run(run func(blueprint schema.Blueprint, index string)) *Grammar_CompileDropForeign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileDropForeign_Call) Return(_a0 string) *Grammar_CompileDropForeign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropForeign_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileDropForeign_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropIfExists provides a mock function with given fields: blueprint
func (_m *Grammar) CompileDropIfExists(blueprint schema.Blueprint) string {
	ret := _m.Called(blueprint)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropIfExists")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint) string); ok {
		r0 = rf(blueprint)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropIfExists'
type Grammar_CompileDropIfExists_Call struct {
	*mock.Call
}

// CompileDropIfExists is a helper method to define mock.On call
//   - blueprint schema.Blueprint
func (_e *Grammar_Expecter) CompileDropIfExists(blueprint interface{}) *Grammar_CompileDropIfExists_Call {
	return &Grammar_CompileDropIfExists_Call{Call: _e.mock.On("CompileDropIfExists", blueprint)}
}

func (_c *Grammar_CompileDropIfExists_Call) Run(run func(blueprint schema.Blueprint)) *Grammar_CompileDropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint))
	})
	return _c
}

func (_c *Grammar_CompileDropIfExists_Call) Return(_a0 string) *Grammar_CompileDropIfExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropIfExists_Call) RunAndReturn(run func(schema.Blueprint) string) *Grammar_CompileDropIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropIndex provides a mock function with given fields: blueprint, index
func (_m *Grammar) CompileDropIndex(blueprint schema.Blueprint, index string) string {
	ret := _m.Called(blueprint, index)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropIndex")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropIndex'
type Grammar_CompileDropIndex_Call struct {
	*mock.Call
}

// CompileDropIndex is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - index string
func (_e *Grammar_Expecter) CompileDropIndex(blueprint interface{}, index interface{}) *Grammar_CompileDropIndex_Call {
	return &Grammar_CompileDropIndex_Call{Call: _e.mock.On("CompileDropIndex", blueprint, index)}
}

func (_c *Grammar_CompileDropIndex_Call) Run(run func(blueprint schema.Blueprint, index string)) *Grammar_CompileDropIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileDropIndex_Call) Return(_a0 string) *Grammar_CompileDropIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropIndex_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileDropIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropPrimary provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropPrimary(blueprint schema.Blueprint, command string) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropPrimary")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropPrimary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropPrimary'
type Grammar_CompileDropPrimary_Call struct {
	*mock.Call
}

// CompileDropPrimary is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command string
func (_e *Grammar_Expecter) CompileDropPrimary(blueprint interface{}, command interface{}) *Grammar_CompileDropPrimary_Call {
	return &Grammar_CompileDropPrimary_Call{Call: _e.mock.On("CompileDropPrimary", blueprint, command)}
}

func (_c *Grammar_CompileDropPrimary_Call) Run(run func(blueprint schema.Blueprint, command string)) *Grammar_CompileDropPrimary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileDropPrimary_Call) Return(_a0 string) *Grammar_CompileDropPrimary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropPrimary_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileDropPrimary_Call {
	_c.Call.Return(run)
	return _c
}

// CompileDropUnique provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileDropUnique(blueprint schema.Blueprint, command string) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileDropUnique")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileDropUnique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileDropUnique'
type Grammar_CompileDropUnique_Call struct {
	*mock.Call
}

// CompileDropUnique is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command string
func (_e *Grammar_Expecter) CompileDropUnique(blueprint interface{}, command interface{}) *Grammar_CompileDropUnique_Call {
	return &Grammar_CompileDropUnique_Call{Call: _e.mock.On("CompileDropUnique", blueprint, command)}
}

func (_c *Grammar_CompileDropUnique_Call) Run(run func(blueprint schema.Blueprint, command string)) *Grammar_CompileDropUnique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileDropUnique_Call) Return(_a0 string) *Grammar_CompileDropUnique_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileDropUnique_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileDropUnique_Call {
	_c.Call.Return(run)
	return _c
}

// CompileForeign provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileForeign(blueprint schema.Blueprint, command *schema.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileForeign")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, *schema.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileForeign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileForeign'
type Grammar_CompileForeign_Call struct {
	*mock.Call
}

// CompileForeign is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command *schema.Command
func (_e *Grammar_Expecter) CompileForeign(blueprint interface{}, command interface{}) *Grammar_CompileForeign_Call {
	return &Grammar_CompileForeign_Call{Call: _e.mock.On("CompileForeign", blueprint, command)}
}

func (_c *Grammar_CompileForeign_Call) Run(run func(blueprint schema.Blueprint, command *schema.Command)) *Grammar_CompileForeign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(*schema.Command))
	})
	return _c
}

func (_c *Grammar_CompileForeign_Call) Return(_a0 string) *Grammar_CompileForeign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileForeign_Call) RunAndReturn(run func(schema.Blueprint, *schema.Command) string) *Grammar_CompileForeign_Call {
	_c.Call.Return(run)
	return _c
}

// CompileIndex provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileIndex(blueprint schema.Blueprint, command *schema.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileIndex")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, *schema.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileIndex'
type Grammar_CompileIndex_Call struct {
	*mock.Call
}

// CompileIndex is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command *schema.Command
func (_e *Grammar_Expecter) CompileIndex(blueprint interface{}, command interface{}) *Grammar_CompileIndex_Call {
	return &Grammar_CompileIndex_Call{Call: _e.mock.On("CompileIndex", blueprint, command)}
}

func (_c *Grammar_CompileIndex_Call) Run(run func(blueprint schema.Blueprint, command *schema.Command)) *Grammar_CompileIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(*schema.Command))
	})
	return _c
}

func (_c *Grammar_CompileIndex_Call) Return(_a0 string) *Grammar_CompileIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileIndex_Call) RunAndReturn(run func(schema.Blueprint, *schema.Command) string) *Grammar_CompileIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CompileIndexes provides a mock function with given fields: database, table
func (_m *Grammar) CompileIndexes(database string, table string) string {
	ret := _m.Called(database, table)

	if len(ret) == 0 {
		panic("no return value specified for CompileIndexes")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(database, table)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileIndexes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileIndexes'
type Grammar_CompileIndexes_Call struct {
	*mock.Call
}

// CompileIndexes is a helper method to define mock.On call
//   - database string
//   - table string
func (_e *Grammar_Expecter) CompileIndexes(database interface{}, table interface{}) *Grammar_CompileIndexes_Call {
	return &Grammar_CompileIndexes_Call{Call: _e.mock.On("CompileIndexes", database, table)}
}

func (_c *Grammar_CompileIndexes_Call) Run(run func(database string, table string)) *Grammar_CompileIndexes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileIndexes_Call) Return(_a0 string) *Grammar_CompileIndexes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileIndexes_Call) RunAndReturn(run func(string, string) string) *Grammar_CompileIndexes_Call {
	_c.Call.Return(run)
	return _c
}

// CompilePrimary provides a mock function with given fields: blueprint, columns
func (_m *Grammar) CompilePrimary(blueprint schema.Blueprint, columns []string) string {
	ret := _m.Called(blueprint, columns)

	if len(ret) == 0 {
		panic("no return value specified for CompilePrimary")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, []string) string); ok {
		r0 = rf(blueprint, columns)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompilePrimary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompilePrimary'
type Grammar_CompilePrimary_Call struct {
	*mock.Call
}

// CompilePrimary is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - columns []string
func (_e *Grammar_Expecter) CompilePrimary(blueprint interface{}, columns interface{}) *Grammar_CompilePrimary_Call {
	return &Grammar_CompilePrimary_Call{Call: _e.mock.On("CompilePrimary", blueprint, columns)}
}

func (_c *Grammar_CompilePrimary_Call) Run(run func(blueprint schema.Blueprint, columns []string)) *Grammar_CompilePrimary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].([]string))
	})
	return _c
}

func (_c *Grammar_CompilePrimary_Call) Return(_a0 string) *Grammar_CompilePrimary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompilePrimary_Call) RunAndReturn(run func(schema.Blueprint, []string) string) *Grammar_CompilePrimary_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRename provides a mock function with given fields: blueprint, to
func (_m *Grammar) CompileRename(blueprint schema.Blueprint, to string) string {
	ret := _m.Called(blueprint, to)

	if len(ret) == 0 {
		panic("no return value specified for CompileRename")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, to)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileRename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRename'
type Grammar_CompileRename_Call struct {
	*mock.Call
}

// CompileRename is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - to string
func (_e *Grammar_Expecter) CompileRename(blueprint interface{}, to interface{}) *Grammar_CompileRename_Call {
	return &Grammar_CompileRename_Call{Call: _e.mock.On("CompileRename", blueprint, to)}
}

func (_c *Grammar_CompileRename_Call) Run(run func(blueprint schema.Blueprint, to string)) *Grammar_CompileRename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileRename_Call) Return(_a0 string) *Grammar_CompileRename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileRename_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileRename_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRenameColumn provides a mock function with given fields: blueprint, from, to
func (_m *Grammar) CompileRenameColumn(blueprint schema.Blueprint, from string, to string) string {
	ret := _m.Called(blueprint, from, to)

	if len(ret) == 0 {
		panic("no return value specified for CompileRenameColumn")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string, string) string); ok {
		r0 = rf(blueprint, from, to)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileRenameColumn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRenameColumn'
type Grammar_CompileRenameColumn_Call struct {
	*mock.Call
}

// CompileRenameColumn is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - from string
//   - to string
func (_e *Grammar_Expecter) CompileRenameColumn(blueprint interface{}, from interface{}, to interface{}) *Grammar_CompileRenameColumn_Call {
	return &Grammar_CompileRenameColumn_Call{Call: _e.mock.On("CompileRenameColumn", blueprint, from, to)}
}

func (_c *Grammar_CompileRenameColumn_Call) Run(run func(blueprint schema.Blueprint, from string, to string)) *Grammar_CompileRenameColumn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Grammar_CompileRenameColumn_Call) Return(_a0 string) *Grammar_CompileRenameColumn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileRenameColumn_Call) RunAndReturn(run func(schema.Blueprint, string, string) string) *Grammar_CompileRenameColumn_Call {
	_c.Call.Return(run)
	return _c
}

// CompileRenameIndex provides a mock function with given fields: blueprint, from, to
func (_m *Grammar) CompileRenameIndex(blueprint schema.Blueprint, from string, to string) string {
	ret := _m.Called(blueprint, from, to)

	if len(ret) == 0 {
		panic("no return value specified for CompileRenameIndex")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string, string) string); ok {
		r0 = rf(blueprint, from, to)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileRenameIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileRenameIndex'
type Grammar_CompileRenameIndex_Call struct {
	*mock.Call
}

// CompileRenameIndex is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - from string
//   - to string
func (_e *Grammar_Expecter) CompileRenameIndex(blueprint interface{}, from interface{}, to interface{}) *Grammar_CompileRenameIndex_Call {
	return &Grammar_CompileRenameIndex_Call{Call: _e.mock.On("CompileRenameIndex", blueprint, from, to)}
}

func (_c *Grammar_CompileRenameIndex_Call) Run(run func(blueprint schema.Blueprint, from string, to string)) *Grammar_CompileRenameIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Grammar_CompileRenameIndex_Call) Return(_a0 string) *Grammar_CompileRenameIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileRenameIndex_Call) RunAndReturn(run func(schema.Blueprint, string, string) string) *Grammar_CompileRenameIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CompileTableComment provides a mock function with given fields: blueprint, comment
func (_m *Grammar) CompileTableComment(blueprint schema.Blueprint, comment string) string {
	ret := _m.Called(blueprint, comment)

	if len(ret) == 0 {
		panic("no return value specified for CompileTableComment")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, string) string); ok {
		r0 = rf(blueprint, comment)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileTableComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileTableComment'
type Grammar_CompileTableComment_Call struct {
	*mock.Call
}

// CompileTableComment is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - comment string
func (_e *Grammar_Expecter) CompileTableComment(blueprint interface{}, comment interface{}) *Grammar_CompileTableComment_Call {
	return &Grammar_CompileTableComment_Call{Call: _e.mock.On("CompileTableComment", blueprint, comment)}
}

func (_c *Grammar_CompileTableComment_Call) Run(run func(blueprint schema.Blueprint, comment string)) *Grammar_CompileTableComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(string))
	})
	return _c
}

func (_c *Grammar_CompileTableComment_Call) Return(_a0 string) *Grammar_CompileTableComment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileTableComment_Call) RunAndReturn(run func(schema.Blueprint, string) string) *Grammar_CompileTableComment_Call {
	_c.Call.Return(run)
	return _c
}

// CompileTables provides a mock function with given fields: database
func (_m *Grammar) CompileTables(database string) string {
	ret := _m.Called(database)

	if len(ret) == 0 {
		panic("no return value specified for CompileTables")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(database)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileTables'
type Grammar_CompileTables_Call struct {
	*mock.Call
}

// CompileTables is a helper method to define mock.On call
//   - database string
func (_e *Grammar_Expecter) CompileTables(database interface{}) *Grammar_CompileTables_Call {
	return &Grammar_CompileTables_Call{Call: _e.mock.On("CompileTables", database)}
}

func (_c *Grammar_CompileTables_Call) Run(run func(database string)) *Grammar_CompileTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Grammar_CompileTables_Call) Return(_a0 string) *Grammar_CompileTables_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileTables_Call) RunAndReturn(run func(string) string) *Grammar_CompileTables_Call {
	_c.Call.Return(run)
	return _c
}

// CompileUnique provides a mock function with given fields: blueprint, command
func (_m *Grammar) CompileUnique(blueprint schema.Blueprint, command *schema.Command) string {
	ret := _m.Called(blueprint, command)

	if len(ret) == 0 {
		panic("no return value specified for CompileUnique")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, *schema.Command) string); ok {
		r0 = rf(blueprint, command)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_CompileUnique_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileUnique'
type Grammar_CompileUnique_Call struct {
	*mock.Call
}

// CompileUnique is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - command *schema.Command
func (_e *Grammar_Expecter) CompileUnique(blueprint interface{}, command interface{}) *Grammar_CompileUnique_Call {
	return &Grammar_CompileUnique_Call{Call: _e.mock.On("CompileUnique", blueprint, command)}
}

func (_c *Grammar_CompileUnique_Call) Run(run func(blueprint schema.Blueprint, command *schema.Command)) *Grammar_CompileUnique_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(*schema.Command))
	})
	return _c
}

func (_c *Grammar_CompileUnique_Call) Return(_a0 string) *Grammar_CompileUnique_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_CompileUnique_Call) RunAndReturn(run func(schema.Blueprint, *schema.Command) string) *Grammar_CompileUnique_Call {
	_c.Call.Return(run)
	return _c
}

// GetAttributeCommands provides a mock function with given fields:
func (_m *Grammar) GetAttributeCommands() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAttributeCommands")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Grammar_GetAttributeCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAttributeCommands'
type Grammar_GetAttributeCommands_Call struct {
	*mock.Call
}

// GetAttributeCommands is a helper method to define mock.On call
func (_e *Grammar_Expecter) GetAttributeCommands() *Grammar_GetAttributeCommands_Call {
	return &Grammar_GetAttributeCommands_Call{Call: _e.mock.On("GetAttributeCommands")}
}

func (_c *Grammar_GetAttributeCommands_Call) Run(run func()) *Grammar_GetAttributeCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Grammar_GetAttributeCommands_Call) Return(_a0 []string) *Grammar_GetAttributeCommands_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_GetAttributeCommands_Call) RunAndReturn(run func() []string) *Grammar_GetAttributeCommands_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyDefault provides a mock function with given fields: blueprint, column
func (_m *Grammar) ModifyDefault(blueprint schema.Blueprint, column schema.ColumnDefinition) string {
	ret := _m.Called(blueprint, column)

	if len(ret) == 0 {
		panic("no return value specified for ModifyDefault")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, schema.ColumnDefinition) string); ok {
		r0 = rf(blueprint, column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_ModifyDefault_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyDefault'
type Grammar_ModifyDefault_Call struct {
	*mock.Call
}

// ModifyDefault is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) ModifyDefault(blueprint interface{}, column interface{}) *Grammar_ModifyDefault_Call {
	return &Grammar_ModifyDefault_Call{Call: _e.mock.On("ModifyDefault", blueprint, column)}
}

func (_c *Grammar_ModifyDefault_Call) Run(run func(blueprint schema.Blueprint, column schema.ColumnDefinition)) *Grammar_ModifyDefault_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_ModifyDefault_Call) Return(_a0 string) *Grammar_ModifyDefault_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_ModifyDefault_Call) RunAndReturn(run func(schema.Blueprint, schema.ColumnDefinition) string) *Grammar_ModifyDefault_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyIncrement provides a mock function with given fields: blueprint, column
func (_m *Grammar) ModifyIncrement(blueprint schema.Blueprint, column schema.ColumnDefinition) string {
	ret := _m.Called(blueprint, column)

	if len(ret) == 0 {
		panic("no return value specified for ModifyIncrement")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, schema.ColumnDefinition) string); ok {
		r0 = rf(blueprint, column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_ModifyIncrement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyIncrement'
type Grammar_ModifyIncrement_Call struct {
	*mock.Call
}

// ModifyIncrement is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) ModifyIncrement(blueprint interface{}, column interface{}) *Grammar_ModifyIncrement_Call {
	return &Grammar_ModifyIncrement_Call{Call: _e.mock.On("ModifyIncrement", blueprint, column)}
}

func (_c *Grammar_ModifyIncrement_Call) Run(run func(blueprint schema.Blueprint, column schema.ColumnDefinition)) *Grammar_ModifyIncrement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_ModifyIncrement_Call) Return(_a0 string) *Grammar_ModifyIncrement_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_ModifyIncrement_Call) RunAndReturn(run func(schema.Blueprint, schema.ColumnDefinition) string) *Grammar_ModifyIncrement_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyNullable provides a mock function with given fields: blueprint, column
func (_m *Grammar) ModifyNullable(blueprint schema.Blueprint, column schema.ColumnDefinition) string {
	ret := _m.Called(blueprint, column)

	if len(ret) == 0 {
		panic("no return value specified for ModifyNullable")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.Blueprint, schema.ColumnDefinition) string); ok {
		r0 = rf(blueprint, column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_ModifyNullable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyNullable'
type Grammar_ModifyNullable_Call struct {
	*mock.Call
}

// ModifyNullable is a helper method to define mock.On call
//   - blueprint schema.Blueprint
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) ModifyNullable(blueprint interface{}, column interface{}) *Grammar_ModifyNullable_Call {
	return &Grammar_ModifyNullable_Call{Call: _e.mock.On("ModifyNullable", blueprint, column)}
}

func (_c *Grammar_ModifyNullable_Call) Run(run func(blueprint schema.Blueprint, column schema.ColumnDefinition)) *Grammar_ModifyNullable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Blueprint), args[1].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_ModifyNullable_Call) Return(_a0 string) *Grammar_ModifyNullable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_ModifyNullable_Call) RunAndReturn(run func(schema.Blueprint, schema.ColumnDefinition) string) *Grammar_ModifyNullable_Call {
	_c.Call.Return(run)
	return _c
}

// TypeBigInteger provides a mock function with given fields: column
func (_m *Grammar) TypeBigInteger(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeBigInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeBigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeBigInteger'
type Grammar_TypeBigInteger_Call struct {
	*mock.Call
}

// TypeBigInteger is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeBigInteger(column interface{}) *Grammar_TypeBigInteger_Call {
	return &Grammar_TypeBigInteger_Call{Call: _e.mock.On("TypeBigInteger", column)}
}

func (_c *Grammar_TypeBigInteger_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeBigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeBigInteger_Call) Return(_a0 string) *Grammar_TypeBigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeBigInteger_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeBigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeBinary provides a mock function with given fields: column
func (_m *Grammar) TypeBinary(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeBinary")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeBinary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeBinary'
type Grammar_TypeBinary_Call struct {
	*mock.Call
}

// TypeBinary is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeBinary(column interface{}) *Grammar_TypeBinary_Call {
	return &Grammar_TypeBinary_Call{Call: _e.mock.On("TypeBinary", column)}
}

func (_c *Grammar_TypeBinary_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeBinary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeBinary_Call) Return(_a0 string) *Grammar_TypeBinary_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeBinary_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeBinary_Call {
	_c.Call.Return(run)
	return _c
}

// TypeBoolean provides a mock function with given fields: column
func (_m *Grammar) TypeBoolean(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeBoolean")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeBoolean_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeBoolean'
type Grammar_TypeBoolean_Call struct {
	*mock.Call
}

// TypeBoolean is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeBoolean(column interface{}) *Grammar_TypeBoolean_Call {
	return &Grammar_TypeBoolean_Call{Call: _e.mock.On("TypeBoolean", column)}
}

func (_c *Grammar_TypeBoolean_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeBoolean_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeBoolean_Call) Return(_a0 string) *Grammar_TypeBoolean_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeBoolean_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeBoolean_Call {
	_c.Call.Return(run)
	return _c
}

// TypeChar provides a mock function with given fields: column
func (_m *Grammar) TypeChar(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeChar")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeChar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeChar'
type Grammar_TypeChar_Call struct {
	*mock.Call
}

// TypeChar is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeChar(column interface{}) *Grammar_TypeChar_Call {
	return &Grammar_TypeChar_Call{Call: _e.mock.On("TypeChar", column)}
}

func (_c *Grammar_TypeChar_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeChar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeChar_Call) Return(_a0 string) *Grammar_TypeChar_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeChar_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeChar_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDate provides a mock function with given fields: column
func (_m *Grammar) TypeDate(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDate")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDate'
type Grammar_TypeDate_Call struct {
	*mock.Call
}

// TypeDate is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeDate(column interface{}) *Grammar_TypeDate_Call {
	return &Grammar_TypeDate_Call{Call: _e.mock.On("TypeDate", column)}
}

func (_c *Grammar_TypeDate_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeDate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDate_Call) Return(_a0 string) *Grammar_TypeDate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDate_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeDate_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDateTime provides a mock function with given fields: column
func (_m *Grammar) TypeDateTime(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDateTime")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDateTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDateTime'
type Grammar_TypeDateTime_Call struct {
	*mock.Call
}

// TypeDateTime is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeDateTime(column interface{}) *Grammar_TypeDateTime_Call {
	return &Grammar_TypeDateTime_Call{Call: _e.mock.On("TypeDateTime", column)}
}

func (_c *Grammar_TypeDateTime_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeDateTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDateTime_Call) Return(_a0 string) *Grammar_TypeDateTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDateTime_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeDateTime_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDateTimeTz provides a mock function with given fields: column
func (_m *Grammar) TypeDateTimeTz(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDateTimeTz")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDateTimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDateTimeTz'
type Grammar_TypeDateTimeTz_Call struct {
	*mock.Call
}

// TypeDateTimeTz is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeDateTimeTz(column interface{}) *Grammar_TypeDateTimeTz_Call {
	return &Grammar_TypeDateTimeTz_Call{Call: _e.mock.On("TypeDateTimeTz", column)}
}

func (_c *Grammar_TypeDateTimeTz_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeDateTimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDateTimeTz_Call) Return(_a0 string) *Grammar_TypeDateTimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDateTimeTz_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeDateTimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDecimal provides a mock function with given fields: column
func (_m *Grammar) TypeDecimal(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDecimal")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDecimal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDecimal'
type Grammar_TypeDecimal_Call struct {
	*mock.Call
}

// TypeDecimal is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeDecimal(column interface{}) *Grammar_TypeDecimal_Call {
	return &Grammar_TypeDecimal_Call{Call: _e.mock.On("TypeDecimal", column)}
}

func (_c *Grammar_TypeDecimal_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeDecimal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDecimal_Call) Return(_a0 string) *Grammar_TypeDecimal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDecimal_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeDecimal_Call {
	_c.Call.Return(run)
	return _c
}

// TypeDouble provides a mock function with given fields: column
func (_m *Grammar) TypeDouble(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeDouble")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeDouble_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeDouble'
type Grammar_TypeDouble_Call struct {
	*mock.Call
}

// TypeDouble is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeDouble(column interface{}) *Grammar_TypeDouble_Call {
	return &Grammar_TypeDouble_Call{Call: _e.mock.On("TypeDouble", column)}
}

func (_c *Grammar_TypeDouble_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeDouble_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeDouble_Call) Return(_a0 string) *Grammar_TypeDouble_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeDouble_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeDouble_Call {
	_c.Call.Return(run)
	return _c
}

// TypeEnum provides a mock function with given fields: column
func (_m *Grammar) TypeEnum(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeEnum")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeEnum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeEnum'
type Grammar_TypeEnum_Call struct {
	*mock.Call
}

// TypeEnum is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeEnum(column interface{}) *Grammar_TypeEnum_Call {
	return &Grammar_TypeEnum_Call{Call: _e.mock.On("TypeEnum", column)}
}

func (_c *Grammar_TypeEnum_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeEnum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeEnum_Call) Return(_a0 string) *Grammar_TypeEnum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeEnum_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeEnum_Call {
	_c.Call.Return(run)
	return _c
}

// TypeFloat provides a mock function with given fields: column
func (_m *Grammar) TypeFloat(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeFloat")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeFloat'
type Grammar_TypeFloat_Call struct {
	*mock.Call
}

// TypeFloat is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeFloat(column interface{}) *Grammar_TypeFloat_Call {
	return &Grammar_TypeFloat_Call{Call: _e.mock.On("TypeFloat", column)}
}

func (_c *Grammar_TypeFloat_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeFloat_Call) Return(_a0 string) *Grammar_TypeFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeFloat_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeFloat_Call {
	_c.Call.Return(run)
	return _c
}

// TypeInteger provides a mock function with given fields: column
func (_m *Grammar) TypeInteger(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeInteger")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeInteger'
type Grammar_TypeInteger_Call struct {
	*mock.Call
}

// TypeInteger is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeInteger(column interface{}) *Grammar_TypeInteger_Call {
	return &Grammar_TypeInteger_Call{Call: _e.mock.On("TypeInteger", column)}
}

func (_c *Grammar_TypeInteger_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeInteger_Call) Return(_a0 string) *Grammar_TypeInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeInteger_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TypeJson provides a mock function with given fields: column
func (_m *Grammar) TypeJson(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeJson")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeJson'
type Grammar_TypeJson_Call struct {
	*mock.Call
}

// TypeJson is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeJson(column interface{}) *Grammar_TypeJson_Call {
	return &Grammar_TypeJson_Call{Call: _e.mock.On("TypeJson", column)}
}

func (_c *Grammar_TypeJson_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeJson_Call) Return(_a0 string) *Grammar_TypeJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeJson_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeJson_Call {
	_c.Call.Return(run)
	return _c
}

// TypeJsonb provides a mock function with given fields: column
func (_m *Grammar) TypeJsonb(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeJsonb")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeJsonb_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeJsonb'
type Grammar_TypeJsonb_Call struct {
	*mock.Call
}

// TypeJsonb is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeJsonb(column interface{}) *Grammar_TypeJsonb_Call {
	return &Grammar_TypeJsonb_Call{Call: _e.mock.On("TypeJsonb", column)}
}

func (_c *Grammar_TypeJsonb_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeJsonb_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeJsonb_Call) Return(_a0 string) *Grammar_TypeJsonb_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeJsonb_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeJsonb_Call {
	_c.Call.Return(run)
	return _c
}

// TypeString provides a mock function with given fields: column
func (_m *Grammar) TypeString(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeString")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeString'
type Grammar_TypeString_Call struct {
	*mock.Call
}

// TypeString is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeString(column interface{}) *Grammar_TypeString_Call {
	return &Grammar_TypeString_Call{Call: _e.mock.On("TypeString", column)}
}

func (_c *Grammar_TypeString_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeString_Call) Return(_a0 string) *Grammar_TypeString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeString_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeString_Call {
	_c.Call.Return(run)
	return _c
}

// TypeText provides a mock function with given fields: column
func (_m *Grammar) TypeText(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeText")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeText'
type Grammar_TypeText_Call struct {
	*mock.Call
}

// TypeText is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeText(column interface{}) *Grammar_TypeText_Call {
	return &Grammar_TypeText_Call{Call: _e.mock.On("TypeText", column)}
}

func (_c *Grammar_TypeText_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeText_Call) Return(_a0 string) *Grammar_TypeText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeText_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeText_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTime provides a mock function with given fields: column
func (_m *Grammar) TypeTime(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTime")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTime'
type Grammar_TypeTime_Call struct {
	*mock.Call
}

// TypeTime is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeTime(column interface{}) *Grammar_TypeTime_Call {
	return &Grammar_TypeTime_Call{Call: _e.mock.On("TypeTime", column)}
}

func (_c *Grammar_TypeTime_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTime_Call) Return(_a0 string) *Grammar_TypeTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTime_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeTime_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTimeTz provides a mock function with given fields: column
func (_m *Grammar) TypeTimeTz(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTimeTz")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTimeTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTimeTz'
type Grammar_TypeTimeTz_Call struct {
	*mock.Call
}

// TypeTimeTz is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeTimeTz(column interface{}) *Grammar_TypeTimeTz_Call {
	return &Grammar_TypeTimeTz_Call{Call: _e.mock.On("TypeTimeTz", column)}
}

func (_c *Grammar_TypeTimeTz_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeTimeTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTimeTz_Call) Return(_a0 string) *Grammar_TypeTimeTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTimeTz_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeTimeTz_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTimestamp provides a mock function with given fields: column
func (_m *Grammar) TypeTimestamp(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTimestamp")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTimestamp'
type Grammar_TypeTimestamp_Call struct {
	*mock.Call
}

// TypeTimestamp is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeTimestamp(column interface{}) *Grammar_TypeTimestamp_Call {
	return &Grammar_TypeTimestamp_Call{Call: _e.mock.On("TypeTimestamp", column)}
}

func (_c *Grammar_TypeTimestamp_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTimestamp_Call) Return(_a0 string) *Grammar_TypeTimestamp_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTimestamp_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// TypeTimestampTz provides a mock function with given fields: column
func (_m *Grammar) TypeTimestampTz(column schema.ColumnDefinition) string {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TypeTimestampTz")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(schema.ColumnDefinition) string); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Grammar_TypeTimestampTz_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeTimestampTz'
type Grammar_TypeTimestampTz_Call struct {
	*mock.Call
}

// TypeTimestampTz is a helper method to define mock.On call
//   - column schema.ColumnDefinition
func (_e *Grammar_Expecter) TypeTimestampTz(column interface{}) *Grammar_TypeTimestampTz_Call {
	return &Grammar_TypeTimestampTz_Call{Call: _e.mock.On("TypeTimestampTz", column)}
}

func (_c *Grammar_TypeTimestampTz_Call) Run(run func(column schema.ColumnDefinition)) *Grammar_TypeTimestampTz_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.ColumnDefinition))
	})
	return _c
}

func (_c *Grammar_TypeTimestampTz_Call) Return(_a0 string) *Grammar_TypeTimestampTz_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Grammar_TypeTimestampTz_Call) RunAndReturn(run func(schema.ColumnDefinition) string) *Grammar_TypeTimestampTz_Call {
	_c.Call.Return(run)
	return _c
}

// NewGrammar creates a new instance of Grammar. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGrammar(t interface {
	mock.TestingT
	Cleanup(func())
}) *Grammar {
	mock := &Grammar{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
